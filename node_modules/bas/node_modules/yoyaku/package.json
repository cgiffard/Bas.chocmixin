{
  "name": "yoyaku",
  "version": "0.0.12",
  "description": "Easily create promise-like APIs with this simple wrapper.",
  "main": "yoyaku.js",
  "scripts": {
    "test": "mocha -R spec"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/cgiffard/Yoyaku.git"
  },
  "keywords": [
    "promise",
    "contract",
    "yakusoku",
    "yoyaku",
    "promises",
    "callback",
    "callbackhell",
    "hell"
  ],
  "devDependencies": {
    "mocha": "1.8.x",
    "chai": "~1.5.0"
  },
  "author": "",
  "license": "BSD",
  "readme": "Yoyaku\n======\n\n*\tAvoid callback hell with this ultra-simple wrapper for your functions.\n*\tEasily streamline node's first-argument-as-error style callbacks.\n*\tAutomatically wrap entire APIs, such as node's `fs`.\n*\tAllows easy currying of functions to an arbitrarily defined depth\n*\tDeferred execution: passing a function call without ugly `function(){}` syntax.\n\t(See [example](#deferred-execution))\n\n*Serving suggestion*: combine with [async](http://github.com/caolan/async) for\nadded flavour (see [recipe](#async).)\n\n### Example 1\n\nIn one line of code, turn node's fs.stat into a promise-like API! Toss `if (err)`\nto the curb!\n\n```javascript\n\nvar yoyaku = require(\"yoyaku\");\n\nvar exists = yoyaku.yepnope(require(\"fs\").stat);\n\n// Now, use it!\nexists(\"foo.txt\")\n\t.nope(function() {\n\t\tconsole.log(\"No - we'd better create that file!\");\n\t})\n\t.yep(function() {\n\t\tconsole.log(\"Yeah my file exists!\");\n\t})\n\n```\n\n### Example 2\n\nThe more flexible method that allows *any* function to be wrapped:\n\n```javascript\nvar yoyaku = require(\"yoyaku\");\n\nfunction existsInt(file,promises) {\n\tfs.stat(file,function(err,data) {\n\t\tif (err) return promises.enoent();\n\t\t\n\t\tpromises.exists(data);\n\t});\n}\n\nvar exists = yoyaku([\"exists\",\"enoent\"],existsInt);\n\nexists(\"./foo.txt\")\n\t.exists(successFunc)\n\t.enoent(failFunc);\n```\n\n### Example 3\n\nAutomatically wrapping an entire API for easy promisey access:\n\n```javascript\nvar yoyaku\t= require(\"yoyaku\"),\n\tfs\t\t= yoyaku.api(require(\"fs\"));\n\nfs.readFile(\"foo.txt\")\n\t.yep(function(data) {\n\t\t// do something with the file data\n\t});\n\n```\n\n### Installing\n\nIf you're using it in the browser, simply include yoyaku.js in your page.\n\nIf you're using node, simply `npm install yoyaku`.\n\n### About\n\nThis won't banish callback hell completely. But used in conjunction with other\ntechniques, it'll certainly help.\n\n`Yoyaku` does not mean promise in Japanese - it means 'reservation', 'contract',\nor 'agreement'. Since this isn't strictly a *promise* API, rather, a *promise-like*\nAPI, I decided to use a promise-like word to describe it. Hence, yoyaku.\n\n### Async\n\nI find this makes async much more palatable. This is a very small example that I\nthink demonstrates how Yoyaku cleans up the callback syntax.\n\n```javascript\n\nvar yoyaku\t= require(\"yoyaku\"),\n\tasync\t= yoyaku.api(require(\"async\")),\n\tfs\t\t= require(\"fs\"),\n\twrite\t= yoyaku.yepnope(fs.writeFile),\n\teach\t= async.each;\n\nfiles = [ \"foo.txt\", \"bar.txt\", \"baz.txt\" ];\n\neach(files,fs.readFile)\n\t.yep(function(data) {\n\t\twrite(\"combined.txt\",data.join(\"\\n\"))\n\t\t\t.yep(somethingToDoWhenFinished);\n\t});\n\nfunction somethingToDoWhenFinished() {\n\tconsole.log(\"It all worked awesomely!\")\n}\n\n```\n\n### Deferred execution\n\nDeferred execution lets you omit function-expression syntax when passing wrapped\nfunctions as callbacks. Instead of calling the function directly, call `.defer`\non it and pass in the arguments you normally would.\n\nTake this example for instance:\n\n```javascript\n\nvar yoyaku\t= require(\"yoyaku\"),\n\tmkdirp\t= yoyaku.yepnope(require(\"mkdirp\")),\n\texists\t= yoyaku.yepnope(require(\"fs\").stat);\n\nfunction createDirIfMissing(path,callback) {\n\texists(path)\n\t\t.yep(callback)\n\t\t.nope(\n\t\t\tmkdirp.defer(path)\n\t\t\t\t.yep(callback));\n}\n```\n\nThe function simply takes a filepath, and creates the directory specified by the\npath if it does not already exist. Writing the function without deferred execution\nand Yoyaku would look like:\n\n```javascript\n\nvar mkdirp\t= require(\"mkdirp\"),\n\tfs\t\t= require(\"fs\");\n\nfunction createDirIfMissing(path,callback) {\n\tfs.stat(path,function(err) {\n\t\tif (!err) return callback();\n\t\t\n\t\tmkdirp(path,function(err) {\n\t\t\tif (err) throw err;\n\t\t\t\n\t\t\tcallback();\n\t\t});\n\t});\n}\n```\n\nIt's not the reduced line count (5 vs 7 SLOC) that is the main factor in Yoyaku's\nfavour - rather the terseness of the code, and the lack of non-specific cruft,\nlike handlers for error callbacks and function expressions. This has let me be\nmore expressive and feel less hindered by *callback-coding* in my own work. I hope\nit works for you too.\n\n### Function Reference\n\n#### `yoyaku(promiseArray,function)`\n\nWraps a single function in another function that manages promises and callbacks.\nPasses all the arguments the wrapper function was called with through to the\nwrapped function, but adds an additional argument on the end: an map of functions\nnamed according to the array which was passed to `yoyaku` when it was invoked.\n\n#### `yoyaku.yepnope(function, [callwith])`\n\nAutomatically converts node-style callback APIs (callback as last parameter, error\ncondition passed as first parameter to callback if applicable) to a promise-like API.\n\nThe returned promises are `.yep` and `.nope`, hence the name of the method.\n\nIf you do not specify a handler for `.nope`, it will throw an exception should the\nmethod fail. This is desirable behaviour (there's nothing worse than invisible errors\nquietly multiplying inside a program!)\n\n#### `yoyaku.api(object)`\n\nRuns `yoyaku.yepnope` against every function parameter of an object, and saves the\nnewly wrapped functions on a new object. Essentially this converts an entire API\nto a promise-like interface.\n\n#### `wrappedFunction.defer( ...arguments... )`\n\nDefers execution of the function as described in the [deferred execution](#deferred-execution)\nsection of the document above. Takes an arbitrary list of arguments and stores/caches\nthem against a function which it then returns. Executing this returned function will\nin turn execute the originally wrapped function with these arguments.\n\nThis function actually calls `wrappedFunction.curry(0, [args])` behind the scenes.\n\n#### `wrappedFunction.curry(requiredArgumentCount, [...arguments...] )`\n\nCurries the wrapped function. The first parameter tells Yoyaku how many arguments\nto require before the wrapped function is executed. Any successive parameters are\ncached, and passed to the final function in order.\n\nUntil the required number of parameters has been reached or exceeded, Yoyaku will\nreturn a function, which has promise setters available as object methods.\n\n#### `wrappedFunction.last` (experimental)\n\nContains a reference to the returned promise map generated the last time the\nwrapped function was called, deferred, or curried. This enables greater brevity,\nbut potentially enables race conditions where the wrapped function might be used\nsimultaneously somewhere else. Use only where you can guarantee linear execution.\n\n```javascript\n\nyoyaku.yepnope(fs.stat);\n\nfs.stat(\"myfile\");\n\n// do something else\n\nfs.stat.last.yep(function() {});\n```\n\n### Testing\n\n\tnpm test\n\n### Licence (BSD)\n\nCopyright (c) 2013, Christopher Giffard\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n*\tRedistributions of source code must retain the above copyright notice, this list\n\tof conditions and the following disclaimer.\n*\tRedistributions in binary form must reproduce the above copyright notice, this\n\tlist of conditions and the following disclaimer in the documentation and/or\n\tother materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\nIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\nOR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\nADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n",
  "readmeFilename": "README.md",
  "_id": "yoyaku@0.0.12",
  "_from": "yoyaku@0.0.12"
}
